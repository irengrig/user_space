load("@bazel_json//lib:json_parser.bzl", "json_parse")
load(":fetcher.bzl", "get_transitive_modules_rctx")
load(":solver.bzl", "matrix", "traverse_transitive")
load(":semver.bzl", "parse_version", "str_semver")

def _impl(rctx):
    modules_info = get_transitive_modules_rctx(rctx, rctx.attr.this_module_name, rctx.attr.manifest)

    # select head version for the root module
    root_versions = modules_info.modules[rctx.attr.this_module_name]
    head_version = modules_info.full_modules_map[rctx.attr.this_module_name]["head"]
    map = {}
    map[parse_version(head_version)] = root_versions[parse_version(head_version)]
    modules_info.modules[rctx.attr.this_module_name] = map

    resolved_dependencies = traverse_transitive(modules_info.modules)
    if not resolved_dependencies:
        fail("Can not resolve dependencies for: " + str(modules_info))

    # todo can be more wise
    selected = resolved_dependencies[0]

    text = ["# Generated by @user_space_package_manager"]
    text.append("def generate_macro():")
    for mod in selected:
        # Skip current module
        if mod == rctx.attr.this_module_name:
            continue
        str_version = str_semver(selected[mod])
        mod_versions = modules_info.full_modules_map[mod]["versions"]

        # todo normalize string versions of module versions
        selected_module_version = mod_versions[str_version]

        # todo do proper shifting
        text.append("  " + selected_module_version["workspace_fragment"])
    rctx.file("resolved_modules.bzl", "\n".join(text))
    rctx.file("BUILD")

generate_http_archives = repository_rule(
    implementation = _impl,
    attrs = {
        "manifest": attr.label(allow_single_file = True),
        "this_module_name": attr.string(),
    },
)
